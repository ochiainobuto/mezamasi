<html>

<head>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>webcam/mobilecam 
    <script src="https://mkwy.fr/js/play-all-model-animations.js"></script><!-- animation -->
    <script src="https://mkwy.fr/js/aframe-orbit-controls.min.js"></script><!-- orbit cam around target -->
    <script src="https://mkwy.fr/js/aframe-extras.js"></script><!-- cub-env-map -->
    <!-- <script src="https://unpkg.com/aframe-particle-system-component@1.0.x/dist/aframe-particle-system-component.min.js"></script> -->

</head>

<body>
    <div id="div0"></div>

    <a-scene embedded arjs="debugUIEnabled:false;" renderer="gammaOutput: true;" vr-mode-ui="enabled: false">
        <a-light type="point" intensity="0.3" position="0 5 5"></a-light>
        <a-entity light="type: ambient; color: #ffffff; intensity: 1.0" position="-1 1 0"></a-entity>

        <a-shadow-light
            id="spot-light-primitive"
            type="spot"
            mapsize="2048 2048"
            far="20">
        </a-shadow-light>
        <a-entity
            id="directional-light-entity"
            shadow-light="type: directional; intensity: 0.8; helper: true">
        </a-entity>
        <a-shadow-plane
            id="shadow-plane-primitive
            dimensions="20 20">
        </a-shadow-plane>

        <a-entity
            id="shadow-plane-entity"
            shadow-plane="opacity: 0.4">
        </a-entity>

        <a-assets>
            <a-asset-item id="mezamasikun" src="mezamasi_anim2.glb"></a-asset-item>
            <!-- <a-asset-item id="cupnoodle" src="cupnoodle.gltf"></a-asset-item> -->
            <!-- <a-asset-item id="stage" src="stage.gltf"></a-asset-item> -->
            <audio id="bell" src="bell.mp3"></audio>
        </a-assets>

        <!-- <a-entity position="0 2.25 -15" particle-system="preset: dust; particleCount: 10000"></a-entity> -->

        <a-entity id="root">
            <a-entity 
                id="model"
                gltf-model="#mezamasikun" 
                position="0 0 -3" 
                scale="10.0 10.0 10.0" 
                rotation="0 0 0"
                animation-mixer="clip: run; loop: repeat timeScale: 1.0"
                reflections="type: realtime" 
                cube-env-map="path: cubemap/; extension: jpg; reflectivity: 0.1;"
                shadow>

                <!-- 当たり判定オブジェクト -->
                <a-entity hit-box>
                    <a-entity hitbox class="raycastable" geometry="primitive:cylinder" material="color:blue; opacity: 0.0" scale="0.05 0.1 0.05" position="0 0.05 0" visible="true"></a-entity>
                </a-entity>
                
            </a-entity>

            <a-text id="timer"
                align="center"
                value="00:00" 
                scale="2 2 2" 
                position="0 1.5 -3">
            </a-text>

        <!-- Camera -->
        <a-entity id='cameraWrapper' position="0 -0.5 0">
            <a-camera></a-camera>
        </a-entity>

        <!-- マウスカーソル -->
        <a-entity id="mouseCursor" cursor="rayOrigin: mouse" raycaster="objects: .raycastable"></a-entity>
            

        
    </a-scene>
    <script>
        //Countdown
        var timerElement = document.getElementById('timer');
        var count = 180; //カウントの初期値
        timerID = setInterval('countup()',1000); //1秒毎にcountup()を呼び出し

        function countup() {
            count = count - 1;

            //秒を取得
            const calcSec  = Math.floor(count) % 60;
            const calcMin = Math.floor(count / 60) % 60;

            const _calcSec = calcSec < 10 ? '0' + calcSec : calcSec;
            const _calcMin = calcMin < 10 ? '0' + calcMin : calcMin;

            timerElement.setAttribute('value', _calcMin + ":" + _calcSec);
            //console.log(calcSec);

            if(count < 1) clearInterval(timerID)
        }


        var doc0= document.getElementById("div0");  
        const model = document.getElementById('model');

        //Click Event
        document.addEventListener('click', function (e) {
            //Position
            e.preventDefault();
            const x = e.pageX;
            const y = e.pageY;

            doc0.innerHTML= x + " : " + y;

        });

        function onAnimationRot() {
            console.log("hit" + model.object3D.rotation.y);
            console.log("Math.PI" + Math.PI * 8);
            
            let x = model.object3D.rotation.x;
            let y = model.object3D.rotation.y;
            let z = model.object3D.rotation.z;

            console.log("to" + y);
            
            model.setAttribute('animation', {
                property: 'rotation',
                to: `${x} ${y+ Math.PI * 12} ${z}`,
                dur: 600,
                easing: 'easeInOutQuad',
                loop: 1
            });
        }

        function onAnimationJump() {
            console.log("jump");
            model.setAttribute('animation-mixer', {
                clip: 'jump',
                loop: 1,
                crossFadeDuration: 0.02,
            })
        }

        function onAnimationRun() {
            console.log("Run");

            model.setAttribute('animation-mixer', {
                clip: 'run',
                loop: 'repeat',
                crossFadeDuration: 0.1,
            })
        }

        var rotationSpeed = 10.0;
        var currentRotation = new THREE.Euler();
        var direction = new THREE.Vector3(0, 0, -1);
        var goal = new THREE.Vector3();
        var direction = new THREE.Vector3();
        var currentRotation = new THREE.Euler();

        // ゴールをランダムな位置に設定する関数
        function setRandomGoal() {
            goal.x = Math.random() * 10 - 5;
            goal.y = 0;
            goal.z = Math.random() * 4 - 2 - 2;

        }

        // ゴールを最初に設定する
        setRandomGoal();

        // 2秒ごとにゴールをランダムな位置に設定する
        setInterval(setRandomGoal, 1000);
        

        //Update
        function updateScreen(time) {
            // console.log("update");
            direction.subVectors(model.object3D.position, goal).normalize();

            // オブジェクトをゴールの方向に向ける
            var targetRotation = Math.atan2(-direction.x, -direction.z);
            var deltaRotation = targetRotation - currentRotation.y;

            // 回転を制限するために、deltaRotationを -π から π の範囲に制限する
            deltaRotation = ((deltaRotation + Math.PI) % (2 * Math.PI)) - Math.PI;

            // 回転を徐々に適用する
            currentRotation.y += deltaRotation * rotationSpeed / 400;

            // 回転を反映する
            model.object3D.rotation.set(currentRotation.x, currentRotation.y, currentRotation.z);
            // console.log("currentRotation: " + currentRotation);

            //get model vector
            var vector = new THREE.Vector3();
            model.object3D.getWorldDirection(vector);
            vector.multiplyScalar(0.03);
            model.object3D.position.add(vector);


        }

        //Hit
        AFRAME.registerComponent('hit-box', {
            init:function(){
                this.el.addEventListener('click', ()=>{

                    var audio = document.querySelector('#bell');
                    audio.play();

                    model.removeAttribute('animation-mixer', onAnimationRun);
                    model.removeAttribute('animation-mixer', onAnimationJump);
                    onAnimationJump();
                    model.addEventListener('animation-loop', onAnimationRun)
                    // model.removeEventListener('animation-finished', onAnimationJump)

                    model.removeAttribute('animation', onAnimationRot);
                    onAnimationRot();
                    model.addEventListener('animationend', onAnimationRot);

                });
            }
        });

        // ブラウザのレンダリングのタイミングにあわせて表示を更新
        (function loop() {
            updateScreen();

            // update();
            window.requestAnimationFrame(loop);
        }());

    </script>
</body>

</html>