<html>

<head>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>

    <script src="https://mkwy.fr/js/play-all-model-animations.js"></script><!-- animation -->
    <script src="https://mkwy.fr/js/aframe-orbit-controls.min.js"></script><!-- orbit cam around target -->
    <script src="https://mkwy.fr/js/aframe-extras.js"></script><!-- cub-env-map -->
    <script src="https://unpkg.com/aframe-particle-system-component@1.0.x/dist/aframe-particle-system-component.min.js"></script>

</head>

<body>
    <div id="div0"></div>

    <a-scene embedded arjs="debugUIEnabled:false;" renderer="gammaOutput: true;" vr-mode-ui="enabled: false">
        <a-light type="point" intensity="0.3" position="0 5 5"></a-light>
        <a-entity light="type: ambient; color: #ffffff; intensity: 1.0" position="-1 1 0"></a-entity>

        <a-shadow-light
            id="spot-light-primitive"
            type="spot"
            mapsize="2048 2048"
            far="20">
        </a-shadow-light>
        <a-entity
            id="directional-light-entity"
            shadow-light="type: directional; intensity: 0.8; helper: true">
        </a-entity>
        <a-shadow-plane
            id="shadow-plane-primitive
            dimensions="20 20">
        </a-shadow-plane>
        <a-entity
            id="shadow-plane-entity"
            shadow-plane="opacity: 0.4">
        </a-entity>

        <a-assets>
            <a-asset-item id="mezamasikun" src="mezamasi_anim.gltf"></a-asset-item>
            <a-asset-item id="cupnoodle" src="cupnoodle.gltf"></a-asset-item>
            <!-- <a-asset-item id="stage" src="stage.gltf"></a-asset-item>
            <audio id="audio" src="bell.mp3"></audio> -->
        </a-assets>

        <a-entity position="0 2.25 -15" particle-system="preset: dust; particleCount: 10000"></a-entity>

        <a-entity id="root">
            <a-entity gltf-model="#mezamasikun" 
                position="0.5 1 -2" 
                scale="10.0 10.0 10.0" 
                rotation="0 -20 0 "
                animation-mixer 
                reflections="type: realtime" 
                cube-env-map="path: cubemap/; extension: jpg; reflectivity: 0.1;"
                shadow>
            </a-entity>

            <a-entity gltf-model="#cupnoodle" 
                position="-0.5 2 -2" 
                rotation="0 20 0 "
                scale="0.2 0.16 0.2" 
                animation-mixer 
                reflections="type: realtime" 
                cube-env-map="path: cubemap/; extension: jpg; reflectivity: 0.1;"
                shadow>
            </a-entity>

            <a-text id="timer"
                value="00:00" 
                scale="2 2 2" 
                position="0 2.5 -2">
            </a-text>
            <!-- <a-box 
            position="-1 1.6 -5" 
            animation="property: position; to: 1 8 -10; dur: 2000; easing: linear; loop: true" 
            color="tomato"></a-box> -->

        <!-- Right Side/Back-to-front -->
        <!-- Transparent -->
        <a-circle src="#platform" position="0 1 -2" material="opacity: 0.4; color: red" radius="2" rotation="-90 0 0"></a-circle>

        <a-sky src="digital_painting_cyber_stage.jpg" rotation="180 90 180"></a-sky>
        
        <a-entity id='cameraWrapper' position="0 0 0">
            <a-camera id='camera'>
            </a-camera>
        </a-entity>

    </a-scene>
    <script>
        var doc0= document.getElementById("div0");  
        //doc0.innerHTML= "div0の箇所にテキストを表示します。";   
    
        // document.addEventListener('DOMContentLoaded', function () {
        //     var targetElement = document.getElementById('root');

        //     // 物体を回転させる
        //     var rotate = function (angle) {
        //         // 角度が360以上にならないように
        //         if (angle == -358) {
        //             angle = 0;
        //         } else {
        //             angle -= 0.2;
        //         }
        //         // 次フレームの準備
        //         requestAnimationFrame(rotate.bind(null, angle));
        //         // 属性値を変更して回転させる
        //         targetElement.setAttribute('rotation', '0 ' + angle + ' 0');
        //     }
        //     rotate(0);
        // });
        
        var timerElement = document.getElementById('timer');

        // let countdown = setInterval(function(){
        //     console.log("start");
        //     const now = new Date()  //今の日時
        //     //const target = new Date(now.getFullYear(), now.getMonth() + 1, 0,'23','59','59') //ターゲット日時を取得
        //     const target = new Date(now.getFullYear(), now.getMonth() + 1, 0,'00','03','00') //ターゲット日時を取得
        //     const remainTime = target - now  //差分を取る（ミリ秒で返ってくる

        //     //指定の日時を過ぎていたら処理をしない
        //     if(remainTime < 0) return false 

        //     //秒を取得
        //     const calcSec  = Math.floor(remainTime / 1000) % 60;
        //     const calcMin = Math.floor(remainTime / 1000 / 60) % 60;

        //     const _calcSec = calcSec < 10 ? '0' + calcSec : calcSec;
        //     const _calcMin = calcMin < 10 ? '0' + calcMin : calcMin;

        //     timerElement.setAttribute('value', _calcMin + ":" + _calcSec);
        //     console.log(calcSec);

        //     //指定の日時になればカウントを止める
        //     if(remainTime < 0) clearInterval(countdown)

        // }, 1000)    //1秒間に1度処理

        var count = 180; //カウントの初期値
        timerID = setInterval('countup()',1000); //1秒毎にcountup()を呼び出し

        function countup() {
            count = count - 1;

            //秒を取得
            const calcSec  = Math.floor(count) % 60;
            const calcMin = Math.floor(count / 60) % 60;

            const _calcSec = calcSec < 10 ? '0' + calcSec : calcSec;
            const _calcMin = calcMin < 10 ? '0' + calcMin : calcMin;

            timerElement.setAttribute('value', _calcMin + ":" + _calcSec);
            console.log(calcSec);

            
            if(count < 0) clearInterval(countup)
        }


        // 基本の距離
        // var cameraElement = document.getElementById('camera');
        // var baseDistance = 0 ;
        // console.log(cameraElement);

        // // 距離を測る関数
        // function getDistance ( event ) {
        //     event.preventDefault() ;

        //     var touches = event.changedTouches ;

        //     // 2本以上の指の場合だけ処理
        //     if ( touches.length > 1 ) {
        //         // 座標1 (1本目の指)
        //         var x1 = touches[0].pageX ;
        //         var y1 = touches[0].pageY ;

        //         // 座標2 (2本目の指)
        //         var x2 = touches[1].pageX ;
        //         var y2 = touches[1].pageY ;

        //         // 2点間の距離
        //         return Math.sqrt( Math.pow( x2-x1, 2 ) + Math.pow( y2-y1, 2 ) ) ;
        //     }

        //     return 0 ;
        // }

        // // touchmove
        // document.ontouchmove = function ( event ) {
        //     // 操作開始時の距離
        //     baseDistance = getDistance( event ) ;
        //     cameraElement.setAttribute('zoom', baseDistance);
        //     console.log(baseDistance);
        //     doc0.innerHTML= baseDistance;
        // }

    </script>
</body>

</html>